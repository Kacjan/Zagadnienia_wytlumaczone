
14.05 wytłumaczone przestrzenie nazw, bulitin, kolejność poszukiwania zmiennych itd.

LEGB stand for Local, Enclosing, Global, and Built-in

o co chodzi z if __name__ == __main__

ładowanie modułów i pakietów
pakiety grupują moduły, moduły grupują kod


---------------------------------------------------------------
20.05 

Czym jest algorytm
Jak zapisać algorytm (słownie, punktami, pseudokodem, schematem blokowym)
Rekurencja (jak działa, czemu zabiera pamięć, wspomaganie przez programowanie dynamiczne, zamiana w pętle)
Złożoność obliczeniowa
Intro do VSCode'a
Metody naiwne (BogoSort, SelectionSort, InsertionSort, BubbleSort)
Dziel i zwyciężaj (Merge... tbc)

12:53 kod z wykresami po raz pierwszy

13:25 - algorytmy brute force

~ 15 porównywanie wydajności kodów na wykresali i w listach

złożoność obliczeniowa i czasowa(chyba) ROZMOWA KWALIFIKACYJNA

15:59 to ładnie przeglądał cos w debuggerze z ustawieniem watch. Na tyjm przykładzie łatwo zrozumieć debuggera w Visual Studio Code

-----------------------------------------------------------------------
21.05

mergeSort
quickSort
counting sort
binary search
porównanie wydajności sortowania
szybkie potęgowanie
szybki Fibonacci
zaczątek zachłannego rozwiązania problemu komiwojażera

14:30 Matryce i fibonanci

14:40 zadanie w codewars z encoderem liczb rzymskich

14:55 powrót do fast Fibonacci

15:10 komiwojażer


27.05

9:50 tłumaczenie komiwojażera od początku

10: 28 jak przyśpieszyć komiwojażera za pomoca numpy

10:38 tłumaczona nowsza wersja kodu komiwojażera

10:40 tłumaczone tablice w numpy (taki mały wtręt)

10:55 Metoda Monte Carlo

11:40 tłymaczenie kodu do liczenia liczby PI netodą Monte Carlo

11:50 Podejście gorliwe a leniwe

12.23 struktury danych
    - gdzie sa przechowywane dane w pamięci
    NIE JEST TO JAWNIE PRAKTYCZNE, ALE WARTO WIEDZIEC ŻEBY MIEĆ POJĘCIE
    
FIFO i LIFO - ROZMOWA REKRUTACYJNA


14.50 Listy linkowane zadanie
15.11 rozpisanie listy linkowanej
    
 
    
    
    28.05
9:10 Tłumaczone kilka metod z biblioteki numpy
9:30 wytłumaczenie funkcji hash
    -Może służyć do porównywania kodu / danych. jeśli ja i ktoś wyhaszyją to samo to sa zbieżne.
    -Jak loguję się gdizes to strona nie przechowuje haseł tyko hasze, jeśli hasz z hasła pasuje to nas wpuszcza.
po haszowaniu zbiory
10:03 strony z których "nie korzystać"  coś wspomniał o materiałach darmowych (chyba)
10:15 Mapy wytłumaczone na przykładzie LISTY LINKOWANEJ
10:40 KOPIEC
11:10 sadanie stos
11:30 Drzewa binarne BST - WAŻNE, BĘDZIE PRZY BAZACH DANYCH, TEGO SIĘ NAUCZ
BFS I DFS
12:30 kod BFS wytłumaczony
12:40 co z BFs i DFS na rozmowie kwalifikacyjnej
12:48 Tłumaczenie zadania Dijkstra
13:00 Rozwiązanie Dijkstry
a3:05 o co chodzi z numpy T (moje pytanie)
13:10 zrobienie wykresu w 3D
13:37 Tłumaczenie Dijkstry od początku do końca

------------------------------------------------------------------------------------------------------------------------------------------------

03.06 

10.43 SOLID
12.50 tŁUMACZENIE WZORCÓW PROJEKTOEYCH NA ROZMOWĘ
14:04 factory
14:50
Wzorce strukturalne
Adapter
15.10
Bridge
Composite
~~ 15.40 Dekoratory


04.06 Wzorce Programowania

9:25 Flyweight
fasada
proxy
10:20 Wzorce operacyjne
10:30 command
Chain of command
11.28 Interpreter (Raczej temat akademicki, python sam interpretuje, przydałoby się jakbym pisał własny język programowania)
Iterator
około 13:00 memento (i dlaczego eval jest groźny)
14:00 Obserwer
State
14.49 Strategy
Template
15.25 Wytłumaczone Zadanie z Template
15:26 visitor










